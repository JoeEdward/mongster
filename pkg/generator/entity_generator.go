package generator

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"
)

type data struct {
	EntityName      string
	MandatoryFields []string
}

type entity struct {
	name            string
	mandatoryFields []string
}

func filter(pack string) []entity {
	ents := []entity{}
	entityPath := fmt.Sprintf("%s/src/%s", os.Getenv("GOPATH"), pack)
	dir, err := os.Open(entityPath)
	if err != nil {
		log.Fatal(err)
	}
	files, err := dir.Readdir(-1)
	dir.Close()

	entityPattern := regexp.MustCompile("type (.*) struct")
	mandatoryFieldPattern := regexp.MustCompile("generate:mandatory=(.+)")

	for _, fi := range files {
		e := &entity{
			mandatoryFields: []string{},
		}
		if strings.HasSuffix(fi.Name(), ".go") {
			f, err := os.Open(fmt.Sprintf("%s/%s", entityPath, fi.Name()))
			if err != nil {
				log.Fatalf("error opening source file %s: %v", fi.Name(), err)
			}
			defer f.Close()
			scanner := bufio.NewScanner(f)
			line := 0
			for scanner.Scan() {
				line++
				currLine := scanner.Text()
				if strings.Contains(currLine, "//") && strings.Contains(currLine, "+generate") {
					if mandatoryFieldPattern.MatchString(currLine) {
						fieldString := mandatoryFieldPattern.FindAllStringSubmatch(currLine, -1)[0]
						fields := strings.Split(fieldString[1], ",")
						e.mandatoryFields = append(e.mandatoryFields, fields...)
						//TODO: Verify that fields are string or struct type and handle accordingly. Use package parser to build an ast
					}
					found := false
					for !found {
						if !scanner.Scan() {
							log.Fatal("unexpected end of file while looking for struct\n")
						}
						next := scanner.Text()
						if strings.TrimSpace(next) == "" {
							continue
						}
						if !entityPattern.MatchString(next) {
							log.Fatalf("unexpected token '%s' while looking for struct\n", next)
						}
						match := entityPattern.FindStringSubmatch(next)
						if len(match) != 2 {
							log.Fatalf("malformed struct declaration on line %d", line)
						}
						token := match[1]
						if token == "" {
							log.Fatalf("empty struct name on line %d", line)
						}
						e.name = token
						ents = append(ents, *e)
						found = true
					}
				}
			}

			if err := scanner.Err(); err != nil {
				log.Fatal(err)
			}
		}
	}

	return ents
}

func GenerateEntityApi(opt Options) {
	funcMap := template.FuncMap{
		"ToUpper": strings.Title,
		"ToLower": strings.ToLower,
	}
	t := template.Must(template.New("api").Funcs(funcMap).Parse(tmpl))

	ents := filter(opt.EntityPackage)

	for _, e := range ents {
		buf := new(bytes.Buffer)
		d := &data{
			EntityName:      e.name,
			MandatoryFields: e.mandatoryFields,
		}
		t.Execute(buf, d)
		filename := fmt.Sprintf("%s_api_generated.go", strings.ToLower(e.name))
		fmt.Println("writing", filename)
		err := ioutil.WriteFile(filename, buf.Bytes(), 0644)

		if err != nil {
			log.Fatalf("error writing generated file %s: %v", filename, err)
		}
	}
}

var tmpl = `
// Code generated by mongster generator; DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/gargath/mongster/pkg/entities"
)

func (api *API) List{{ .EntityName | ToUpper }}sHandler(w http.ResponseWriter, r *http.Request) {
	entities, err := api.b.List{{ .EntityName | ToUpper }}s()
	if err != nil {
		log.Printf("failed to list {{ .EntityName}}s: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	entityJson, err := json.MarshalIndent(entities, "", "\t")
	if err != nil {
		log.Printf("failed to marshal JSON: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{\n\t{{ .EntityName }}s:\n"))
	w.Write(entityJson)
	w.Write([]byte("\n}\n"))
}

func (api *API) Insert{{ .EntityName | ToUpper }}Handler(w http.ResponseWriter, r *http.Request) {
	if r.Header.Get("Content-Type") != "application/json" {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(fmt.Sprintf("{\n\terror: \"Content Type %s not supported \"\n}\n", r.Header.Get("Content-Type"))))
		return
	}
	decoder := json.NewDecoder(r.Body)
	var u entities.{{ .EntityName | ToUpper }}
	var errors []error
	err := decoder.Decode(&u)
	if err != nil {
		errors = append(errors, err)
	}
	{{range $idx, $e := .MandatoryFields}}
	if u.{{$e}} == "" {
		errors = append(errors, fmt.Errorf("missing field '{{ $e | ToLower }}'"))
	}
	{{end}}
	if len(errors) > 0 {
		log.Printf("error parsing %v as JSON:", r.Body)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("{\n\terror: \"malformed request document\"\n\terrors: [\n"))
		errstrs := []string{}
		for _, er := range errors {
			errstrs = append(errstrs, er.Error())
		}
		w.Write([]byte(strings.Join(errstrs, ", ")))
		w.Write([]byte("\t]\n}"))
		return
	}
	id, err := api.b.Insert{{ .EntityName | ToUpper }}(&u)
	if err != nil {
		log.Printf("failed to persist {{ .EntityName }}: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	w.Header().Set("Location", fmt.Sprintf("%s/{{ .EntityName }}/%s", api.prefix, id))
	w.WriteHeader(http.StatusCreated)
}
`
